generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id                String         @id @default(uuid())
  email             String         @unique
  password          String
  name              String
  role              Role           @default(EMPLOYEE)
  active            Boolean        @default(true)
  twoFactorEnabled  Boolean        @default(false)
  twoFactorSecret   String?
  backupCodes       String?        // JSON array of backup codes
  phoneNumber       String?
  emailVerified     Boolean        @default(false)
  lastLoginAt       DateTime?
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
  activityLogs      ActivityLog[]
  quotes            Quote[]
  refreshTokens     RefreshToken[]
  sessions          Session[]
  trustedDevices    TrustedDevice[]
}

model Session {
  id        String   @id @default(uuid())
  sessionToken String @unique
  userId    String
  ipAddress String?
  userAgent String?
  expiresAt DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([sessionToken])
  @@index([userId])
}

model RefreshToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model TrustedDevice {
  id              String   @id @default(uuid())
  userId          String
  deviceFingerprint String  // Hash of browser/device characteristics
  deviceName      String?  // User agent or friendly name
  ipAddress       String?
  lastUsedAt      DateTime @default(now())
  expiresAt       DateTime // 7 days from creation
  createdAt       DateTime @default(now())
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, deviceFingerprint])
  @@index([deviceFingerprint])
  @@index([userId])
}

model VerificationToken {
  id        String   @id @default(uuid())
  email     String
  token     String   @unique
  code      String?  // 6-digit verification code
  type      String   // EMAIL_VERIFY, PASSWORD_RESET
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([email])
  @@index([token])
  @@index([code])
}

model Quote {
  id            String        @id @default(uuid())
  quoteNumber   String        @unique
  deviceType    String
  model         String
  network       String
  storage       String
  condition     String
  atlasPrice    Float
  offerPrice    Float
  margin        Float
  customerName  String
  customerEmail String
  customerPhone String
  status        QuoteStatus   @default(PENDING)
  expiresAt     DateTime
  notes         String?
  createdBy     String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  activityLogs  ActivityLog[]
  emailLogs     EmailLog[]
  user          User?         @relation(fields: [createdBy], references: [id])

  @@index([status])
  @@index([createdAt])
  @@index([expiresAt])
  @@index([updatedAt])
  @@index([customerEmail])
  @@index([status, createdAt])
  @@index([status, expiresAt])
}

model PricingData {
  id          String   @id @default(uuid())
  model       String
  deviceType  String
  modelName   String
  storage     String
  network     String
  series      String?  // iPhone series identifier (e.g., "17", "16", "SE", "X") for series overrides
  priceSwap   Float?
  priceGradeA Float?
  priceGradeB Float?
  priceGradeC Float?
  priceGradeD Float?
  priceDOA    Float?
  crackedBack Float?
  crackedLens Float?
  lastUpdated DateTime @default(now())
  isActive    Boolean  @default(true)

  // Manual override prices (null = use margin calculation)
  overrideGradeA  Float?
  overrideGradeB  Float?
  overrideGradeC  Float?
  overrideGradeD  Float?
  overrideDOA     Float?

  // Track when overrides were set
  overrideSetAt   DateTime?
  overrideSetBy   String?

  // Cached calculated offer prices (Atlas price minus margin)
  // These are auto-calculated and stored for performance
  offerGradeA     Float?
  offerGradeB     Float?
  offerGradeC     Float?
  offerGradeD     Float?
  offerDOA        Float?

  // Track when offers were last calculated
  offersCalculatedAt DateTime?

  @@unique([model, network])
  @@index([deviceType, modelName])
  @@index([series])
}

model EmailLog {
  id       String    @id @default(uuid())
  quoteId  String
  type     EmailType
  status   String
  sentAt   DateTime  @default(now())
  metadata String?
  quote    Quote     @relation(fields: [quoteId], references: [id], onDelete: Cascade)

  @@index([quoteId])
  @@index([type])
  @@index([status])
}

model Setting {
  id        String   @id @default(uuid())
  key       String   @unique
  value     String
  category  String
  updatedAt DateTime @updatedAt
}

model ActivityLog {
  id          String   @id @default(uuid())
  userId      String?
  quoteId     String?
  action      String
  description String?
  ipAddress   String?
  userAgent   String?
  createdAt   DateTime @default(now())
  quote       Quote?   @relation(fields: [quoteId], references: [id])
  user        User?    @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([quoteId])
  @@index([action])
  @@index([createdAt])
}

model PricingUpdateLog {
  id             String   @id @default(uuid())
  fileName       String?
  source         String
  recordsAdded   Int      @default(0)
  recordsUpdated Int      @default(0)
  status         String
  error          String?
  executedAt     DateTime @default(now())
}

enum Role {
  ADMIN
  MANAGER
  EMPLOYEE
}

enum QuoteStatus {
  PENDING
  ACCEPTED
  EXPIRED
  CANCELLED
  COMPLETED
  PAID
}

enum EmailType {
  QUOTE_CONFIRMATION
  REMINDER_7_DAYS
  REMINDER_3_DAYS
  REMINDER_1_DAY
  EXPIRED_NOTICE
  ADMIN_NOTIFICATION
}

// Margin configuration for different price ranges and conditions
model MarginTier {
  id            String   @id @default(uuid())
  name          String   // e.g., "Budget", "Mid-Range", "Premium"
  minPrice      Float    // Minimum Atlas price for this tier
  maxPrice      Float    // Maximum Atlas price for this tier

  // Margins for each condition (dollar amounts to deduct from Atlas price)
  marginGradeA  Float    // Margin for Flawless condition
  marginGradeB  Float    // Margin for Good condition
  marginGradeC  Float    // Margin for Fair condition
  marginGradeD  Float    // Margin for Broken condition
  marginDOA     Float    // Margin for No Power condition

  // Optional percentage-based margins (if you want to use % instead of fixed $)
  usePercentage Boolean  @default(false)
  percentGradeA Float?   // Percentage margin for Grade A (if usePercentage is true)
  percentGradeB Float?   // Percentage margin for Grade B
  percentGradeC Float?   // Percentage margin for Grade C
  percentGradeD Float?   // Percentage margin for Grade D
  percentDOA    Float?   // Percentage margin for DOA

  priority      Int      @default(0) // Order of tiers (higher priority = checked first)
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([minPrice, maxPrice])
  @@index([priority])
}

// Rate limiting for production (persists across server restarts)
model RateLimit {
  key       String   @id  // Format: "ip:endpoint"
  count     Int             // Number of requests in current window
  resetTime BigInt          // Timestamp when window resets (milliseconds)
  updatedAt DateTime @updatedAt

  @@index([resetTime])  // For cleanup queries
  @@map("rate_limits")   // Use snake_case table name for raw SQL queries
}

// ============================================
// REPAIR FORM CONFIGURATION
// ============================================

// Device categories (Smartphones, Tablet, Computer, etc.)
model RepairDevice {
  id        String   @id @default(uuid())
  name      String   // "Smartphones", "Tablet", etc.
  slug      String   @unique // "smartphones", "tablet"
  icon      String   // Lucide icon name (e.g. "Smartphone", "Tablet")
  order     Int      @default(0) // Display order
  active    Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  brands    RepairBrand[]
  issues    RepairDeviceIssue[]

  @@index([active, order])
}

// Brands for each device category (Apple, Samsung, etc.)
model RepairBrand {
  id        String   @id @default(uuid())
  name      String   // "Apple", "Samsung"
  deviceId  String   // FK to RepairDevice
  order     Int      @default(0)
  active    Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  device    RepairDevice @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  models    RepairModel[]

  @@unique([deviceId, name])
  @@index([deviceId, active, order])
}

// Models for each brand (iPhone 17 Pro Max, Galaxy S24, etc.)
model RepairModel {
  id        String   @id @default(uuid())
  name      String   // "iPhone 17 Pro Max"
  brandId   String   // FK to RepairBrand
  order     Int      @default(0)
  active    Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  brand     RepairBrand @relation(fields: [brandId], references: [id], onDelete: Cascade)
  issues    RepairModelIssue[]

  @@unique([brandId, name])
  @@index([brandId, active, order])
}

// Repair issues/problems (Screen Damage, Battery, etc.)
model RepairIssue {
  id        String   @id @default(uuid())
  name      String   // "Screen Damage"
  slug      String   @unique // "screen-damage"
  emoji     String   // "ðŸ“±"
  order     Int      @default(0)
  active    Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  devices   RepairDeviceIssue[]
  models    RepairModelIssue[]

  @@index([active, order])
}

// Junction table: Which issues apply to which device types
model RepairDeviceIssue {
  id        String   @id @default(uuid())
  deviceId  String
  issueId   String

  device    RepairDevice @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  issue     RepairIssue  @relation(fields: [issueId], references: [id], onDelete: Cascade)

  @@unique([deviceId, issueId])
  @@index([deviceId])
  @@index([issueId])
}

// Junction table: Which issues apply to which specific models
model RepairModelIssue {
  id        String   @id @default(uuid())
  modelId   String
  issueId   String
  createdAt DateTime @default(now())

  model     RepairModel @relation(fields: [modelId], references: [id], onDelete: Cascade)
  issue     RepairIssue @relation(fields: [issueId], references: [id], onDelete: Cascade)

  @@unique([modelId, issueId])
  @@index([modelId])
  @@index([issueId])
}

// ============================================
// REPAIR BOOKING SUBMISSIONS
// ============================================

model RepairBooking {
  id              String   @id @default(uuid())
  bookingNumber   String   @unique // e.g. "REP-2025-0001"

  // Device info
  deviceType      String
  make            String
  model           String
  issues          String   // JSON array of issue slugs
  description     String?

  // Customer info
  firstName       String
  lastName        String
  email           String
  phone           String

  // Appointment info (null for quote requests)
  appointmentDate String?
  appointmentTime String?
  requestType     String   // "appointment" or "quote"

  // Status tracking
  status          RepairBookingStatus @default(PENDING)

  // Google Calendar integration
  calendarEventId String?  // Google Calendar event ID

  // Internal notes
  notes           String?
  staffNotes      String?

  // Metadata
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([status, createdAt])
  @@index([email])
  @@index([appointmentDate])
  @@index([requestType])
}

enum RepairBookingStatus {
  PENDING       // Initial submission
  CONFIRMED     // Appointment confirmed
  IN_PROGRESS   // Currently being repaired
  COMPLETED     // Repair finished
  CANCELLED     // Customer cancelled
  NO_SHOW       // Customer didn't show up
  QUOTED        // Quote provided (for quote requests)
}
